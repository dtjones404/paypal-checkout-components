{"version":3,"sources":["webpack:///checkout.child.loader.min.js","webpack:///webpack/bootstrap 2338747caf5320952c45","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/zalgo-promise/src/global.js","webpack:///./node_modules/zalgo-promise/src/utils.js","webpack:///./node_modules/zalgo-promise/src/exceptions.js","webpack:///./node_modules/zalgo-promise/src/promise.js","webpack:///./src/loader/index.js","webpack:///./src/lib/namespace.js","webpack:///./src/loader/component.js","webpack:///./src/loader/util.js","webpack:///./src/loader/load.js","webpack:///./src/loader/config.js","webpack:///./src/loader/responder.js"],"names":["e","a","i","window","modules","getPromiseShim","__webpack_require__","Promise","resolver","moduleId","installedModules","exports","module","l","call","resolve","val","reject","err","all","promises","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","./node_modules/webpack/buildin/global.js","g","_typeof","Symbol","iterator","obj","constructor","this","Function","eval","./node_modules/zalgo-promise/src/global.js","__webpack_exports__","global","getGlobal","glob","Error","__zalgopromise__","flushPromises","activeCount","possiblyUnhandledPromiseHandlers","dispatchedErrors","./node_modules/zalgo-promise/src/index.js","utils_isPromise","item","Window","toString","then","dispatchPossiblyUnhandledError","indexOf","push","setTimeout","j","length","exceptions_onPossiblyUnhandledException","handler","cancel","splice","_classCallCheck","instance","Constructor","TypeError","value","promise_ZalgoPromise","ZalgoPromise","_this","resolved","rejected","errorHandled","handlers","result","error","isAsync","res","dispatch","_this2","asyncReject","_this3","dispatching","_handlers$i","onSuccess","onError","promise","flushQueue","undefined","timeout","time","_this4","clearTimeout","toPromise","count","results","prom","hash","keys","map","key","items","method","onPossiblyUnhandledException","context","args","apply","delay","isPromise","flush","promisesToFlush","_iterator","_isArray","Array","isArray","_i","_ref","next","done","./src/loader/index.js","_extends","assign","target","arguments","source","_interface","xports","namespaces","childnamespaces","namespace","_iterator3","_isArray3","_i3","_extends2","_ref3","childname","childnamespace","_iterator2","_isArray2","_i2","_ref2","./src/loader/interface.js","isCheckoutXComponent","seg","split","config","name_separator","xcomponent","ppcheckout","getVersion","replace","isLatest","version","Boolean","major_version","latest_version","loadScript","url","prop","attrs","callback","container","document","body","head","script","createElement","src","onload","onerror","attr","setAttribute","appendChild","warn","_len","_key","message","join","console","log","parseQuery","queryString","location","search","params","slice","pair","decodeURIComponent","onLoadCheckoutIntegration","integrationResponder","listen","getIntegrationURLs","latest","major","checkoutjs_url","minor","getIntegrationProps","props","script_props","query","env","stage","xchild_global","data-paypal-checkout","data-no-bridge","data-state","loaded","callbacks","shift","respond","urls","Date","now","stack","0"],"mappings":"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","file":"checkout.child.loader.min.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap\n/******/ \tfunction getPromiseShim() {\n/******/ \t                            return __webpack_require__(\"./node_modules/zalgo-promise/src/index.js\")[\"ZalgoPromise\"];\n/******/ \t                        }\n/******/\n/******/ \t                        function Promise(resolver) {\n/******/ \t                            return new (getPromiseShim())(resolver);\n/******/ \t                        }\n/******/\n/******/ \t                        Promise.resolve = function(val)      { return getPromiseShim().resolve(val);  };\n/******/ \t                        Promise.reject  = function(err)      { return getPromiseShim().reject(err);   };\n/******/ \t                        Promise.all     = function(promises) { return getPromiseShim().all(promises); };\n/******/\n/******/ \t                        \n/******/ \t                    \n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"https://www.paypalobjects.com/api/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/webpack/buildin/global.js\":\n/***/ (function(module, exports) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n\n/***/ \"./node_modules/zalgo-promise/src/global.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getGlobal;\nfunction getGlobal() {\n\n    var glob = void 0;\n\n    if (typeof window !== 'undefined') {\n        glob = window;\n    } else if (typeof global !== 'undefined') {\n        glob = global;\n    } else {\n        throw new Error('Can not find global');\n    }\n\n    if (!glob.__zalgopromise__) {\n        glob.__zalgopromise__ = {\n            flushPromises: [],\n            activeCount: 0,\n            possiblyUnhandledPromiseHandlers: [],\n            dispatchedErrors: []\n        };\n    }\n\n    return glob.__zalgopromise__;\n}\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(\"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/zalgo-promise/src/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/utils.js\n\nfunction utils_isPromise(item) {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        var _toString = {}.toString;\n\n        if (_toString) {\n            var name = _toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n// EXTERNAL MODULE: ./node_modules/zalgo-promise/src/global.js\nvar global = __webpack_require__(\"./node_modules/zalgo-promise/src/global.js\");\n\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/exceptions.js\n\n\n\nfunction dispatchPossiblyUnhandledError(err) {\n\n    if (Object(global[\"a\" /* getGlobal */])().dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    Object(global[\"a\" /* getGlobal */])().dispatchedErrors.push(err);\n\n    setTimeout(function () {\n        throw err;\n    }, 1);\n\n    for (var j = 0; j < Object(global[\"a\" /* getGlobal */])().possiblyUnhandledPromiseHandlers.length; j++) {\n        Object(global[\"a\" /* getGlobal */])().possiblyUnhandledPromiseHandlers[j](err);\n    }\n}\n\nfunction exceptions_onPossiblyUnhandledException(handler) {\n    Object(global[\"a\" /* getGlobal */])().possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel: function cancel() {\n            Object(global[\"a\" /* getGlobal */])().possiblyUnhandledPromiseHandlers.splice(Object(global[\"a\" /* getGlobal */])().possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/promise.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar promise_ZalgoPromise = function () {\n    function ZalgoPromise(handler) {\n        var _this = this;\n\n        _classCallCheck(this, ZalgoPromise);\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            var _result = void 0;\n            var _error = void 0;\n            var resolved = false;\n            var rejected = false;\n            var isAsync = false;\n\n            try {\n                handler(function (res) {\n                    if (isAsync) {\n                        _this.resolve(res);\n                    } else {\n                        resolved = true;\n                        _result = res;\n                    }\n                }, function (err) {\n                    if (isAsync) {\n                        _this.reject(err);\n                    } else {\n                        rejected = true;\n                        _error = err;\n                    }\n                });\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(_result);\n            } else if (rejected) {\n                this.reject(_error);\n            }\n        }\n    }\n\n    ZalgoPromise.prototype.resolve = function resolve(result) {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (utils_isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    };\n\n    ZalgoPromise.prototype.reject = function reject(error) {\n        var _this2 = this;\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (utils_isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            var _err = error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error);\n            error = new Error('Expected reject to be called with Error, got ' + _err);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(function () {\n                if (!_this2.errorHandled) {\n                    dispatchPossiblyUnhandledError(error);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    };\n\n    ZalgoPromise.prototype.asyncReject = function asyncReject(error) {\n        this.errorHandled = true;\n        this.reject(error);\n    };\n\n    ZalgoPromise.prototype.dispatch = function dispatch() {\n        var _this3 = this;\n\n        var dispatching = this.dispatching,\n            resolved = this.resolved,\n            rejected = this.rejected,\n            handlers = this.handlers;\n\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        Object(global[\"a\" /* getGlobal */])().activeCount += 1;\n\n        var _loop = function _loop(i) {\n            var _handlers$i = handlers[i],\n                onSuccess = _handlers$i.onSuccess,\n                onError = _handlers$i.onError,\n                promise = _handlers$i.promise;\n\n\n            var result = void 0;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(_this3.value) : _this3.value;\n                } catch (err) {\n                    promise.reject(err);\n                    return 'continue';\n                }\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(_this3.error);\n                    return 'continue';\n                }\n\n                try {\n                    result = onError(_this3.error);\n                } catch (err) {\n                    promise.reject(err);\n                    return 'continue';\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n            } else if (utils_isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n                } else {\n                    // $FlowFixMe\n                    result.then(function (res) {\n                        promise.resolve(res);\n                    }, function (err) {\n                        promise.reject(err);\n                    });\n                }\n            } else {\n\n                promise.resolve(result);\n            }\n        };\n\n        for (var i = 0; i < handlers.length; i++) {\n            var _ret = _loop(i);\n\n            if (_ret === 'continue') continue;\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        Object(global[\"a\" /* getGlobal */])().activeCount -= 1;\n\n        if (Object(global[\"a\" /* getGlobal */])().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    };\n\n    ZalgoPromise.prototype.then = function then(onSuccess, onError) {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        var promise = new ZalgoPromise();\n\n        this.handlers.push({\n            promise: promise,\n            onSuccess: onSuccess,\n            onError: onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    };\n\n    ZalgoPromise.prototype['catch'] = function _catch(onError) {\n        return this.then(undefined, onError);\n    };\n\n    ZalgoPromise.prototype['finally'] = function _finally(handler) {\n        return this.then(function (result) {\n            return ZalgoPromise['try'](handler).then(function () {\n                return result;\n            });\n        }, function (err) {\n            return ZalgoPromise['try'](handler).then(function () {\n                throw err;\n            });\n        });\n    };\n\n    ZalgoPromise.prototype.timeout = function timeout(time, err) {\n        var _this4 = this;\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        var timeout = setTimeout(function () {\n\n            if (_this4.resolved || _this4.rejected) {\n                return;\n            }\n\n            _this4.reject(err || new Error('Promise timed out after ' + time + 'ms'));\n        }, time);\n\n        return this.then(function (result) {\n            clearTimeout(timeout);\n            return result;\n        });\n    };\n\n    // $FlowFixMe\n\n\n    ZalgoPromise.prototype.toPromise = function toPromise() {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new Error('Could not find Promise');\n        }\n        // $FlowFixMe\n        return Promise.resolve(this);\n    };\n\n    ZalgoPromise.resolve = function resolve(value) {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (utils_isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise(function (resolve, reject) {\n                return value.then(resolve, reject);\n            });\n        }\n\n        return new ZalgoPromise().resolve(value);\n    };\n\n    ZalgoPromise.reject = function reject(error) {\n        return new ZalgoPromise().reject(error);\n    };\n\n    ZalgoPromise.all = function all(promises) {\n\n        var promise = new ZalgoPromise();\n        var count = promises.length;\n        var results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        var _loop2 = function _loop2(i) {\n            var prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    return 'continue';\n                }\n            } else if (!utils_isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                return 'continue';\n            }\n\n            ZalgoPromise.resolve(prom).then(function (result) {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, function (err) {\n                promise.reject(err);\n            });\n        };\n\n        for (var i = 0; i < promises.length; i++) {\n            var _ret2 = _loop2(i);\n\n            if (_ret2 === 'continue') continue;\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    };\n\n    ZalgoPromise.hash = function hash(promises) {\n        var result = {};\n\n        return ZalgoPromise.all(Object.keys(promises).map(function (key) {\n            return ZalgoPromise.resolve(promises[key]).then(function (value) {\n                result[key] = value;\n            });\n        })).then(function () {\n            return result;\n        });\n    };\n\n    ZalgoPromise.map = function map(items, method) {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    };\n\n    ZalgoPromise.onPossiblyUnhandledException = function onPossiblyUnhandledException(handler) {\n        return exceptions_onPossiblyUnhandledException(handler);\n    };\n\n    ZalgoPromise['try'] = function _try(method, context, args) {\n\n        var result = void 0;\n\n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    };\n\n    ZalgoPromise.delay = function delay(_delay) {\n        return new ZalgoPromise(function (resolve) {\n            setTimeout(resolve, _delay);\n        });\n    };\n\n    ZalgoPromise.isPromise = function isPromise(value) {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return utils_isPromise(value);\n    };\n\n    ZalgoPromise.flush = function flush() {\n        var promise = new ZalgoPromise();\n        Object(global[\"a\" /* getGlobal */])().flushPromises.push(promise);\n\n        if (Object(global[\"a\" /* getGlobal */])().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    };\n\n    ZalgoPromise.flushQueue = function flushQueue() {\n        var promisesToFlush = Object(global[\"a\" /* getGlobal */])().flushPromises;\n        Object(global[\"a\" /* getGlobal */])().flushPromises = [];\n\n        for (var _iterator = promisesToFlush, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n            } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n            }\n\n            var _promise = _ref;\n\n            _promise.resolve();\n        }\n    };\n\n    return ZalgoPromise;\n}();\n\n\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/index.js\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"ZalgoPromise\", function() { return promise_ZalgoPromise; });\n\n\n/***/ }),\n\n/***/ \"./src/loader/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/lib/namespace.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction extendNamespace(xports) {\n    var namespaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var childnamespaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n\n    for (var _iterator = namespaces, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n        }\n\n        var name = _ref;\n\n        var namespace = window[name];\n\n        if (!namespace) {\n            continue;\n        }\n\n        for (var _iterator3 = childnamespaces, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n            var _extends2;\n\n            var _ref3;\n\n            if (_isArray3) {\n                if (_i3 >= _iterator3.length) break;\n                _ref3 = _iterator3[_i3++];\n            } else {\n                _i3 = _iterator3.next();\n                if (_i3.done) break;\n                _ref3 = _i3.value;\n            }\n\n            var childname = _ref3;\n\n            var childnamespace = xports[childname];\n\n            if (namespace[childname]) {\n                childnamespace = _extends({}, namespace[childname], childnamespace);\n            }\n\n            xports = _extends({}, namespace, xports, (_extends2 = {}, _extends2[childname] = childnamespace, _extends2));\n        }\n    }\n\n    for (var _iterator2 = namespaces, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n        } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n        }\n\n        var _name = _ref2;\n\n        window[_name] = xports;\n    }\n\n    return xports;\n}\n// CONCATENATED MODULE: ./src/loader/index.js\n\n\nvar _interface = __webpack_require__(\"./src/loader/interface.js\"); // eslint-disable-line import/no-commonjs\n\nextendNamespace(_interface, ['paypal']);\n\n/***/ }),\n\n/***/ \"./src/loader/interface.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/loader/config.js\nvar config = {\n    checkoutjs_url: 'https://www.paypalobjects.com/api/checkout{version}.js',\n    major_version: '4',\n    latest_version: 'latest',\n    xcomponent: 'xcomponent',\n    ppcheckout: 'ppcheckout',\n    xchild_global: 'xchild',\n    name_separator: '__',\n\n    script_props: {\n        'data-paypal-checkout': '',\n        'data-no-bridge': '',\n        'data-state': 'ppxo_checkout'\n    }\n};\n// CONCATENATED MODULE: ./src/loader/responder.js\nfunction responder() {\n\n    var callbacks = [];\n    var loaded = false;\n\n    var err = void 0;\n    var res = void 0;\n\n    function flush() {\n        if (loaded) {\n            while (callbacks.length) {\n                callbacks.shift()(err, res);\n            }\n        }\n    }\n\n    function respond(error, result) {\n\n        loaded = true;\n        err = error;\n        res = result;\n\n        flush();\n    }\n\n    function listen(callback) {\n        callbacks.push(callback);\n        flush();\n    }\n\n    return { respond: respond, listen: listen };\n}\n// CONCATENATED MODULE: ./src/loader/component.js\n\n\nfunction isCheckoutXComponent() {\n    if (window.name) {\n        var seg = window.name.split(config.name_separator);\n\n        if (seg[0] === config.xcomponent && seg[1] === config.ppcheckout) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction getVersion() {\n\n    if (!isCheckoutXComponent()) {\n        throw new Error('Can not get version for non-xcomponent');\n    }\n\n    return window.name.split(config.name_separator)[2].replace(/_/g, '.');\n}\n\nfunction isLatest() {\n\n    if (!isCheckoutXComponent()) {\n        return false;\n    }\n\n    var version = getVersion();\n\n    return Boolean(version === config.major_version || version === config.latest_version);\n}\n// CONCATENATED MODULE: ./src/loader/util.js\nfunction loadScript(url, prop, attrs, callback) {\n\n    if (window[prop]) {\n        return callback(null, window[prop]);\n    }\n\n    var container = document.body || document.head;\n\n    if (!container) {\n        return callback(new Error('Can not find container to insert script into'));\n    }\n\n    var script = document.createElement('script');\n\n    script.src = url;\n\n    script.onload = function () {\n        if (!window[prop]) {\n            return callback(new Error('Expected ' + prop + ' to be present on window'));\n        }\n\n        return callback(null, window[prop]);\n    };\n\n    script.onerror = function (err) {\n        return callback(err);\n    };\n\n    for (var _iterator = Object.keys(attrs), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n        }\n\n        var attr = _ref;\n\n        script.setAttribute(attr, attrs[attr]);\n    }\n\n    container.appendChild(script);\n}\n\nfunction warn() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    var message = args.join(' ');\n\n    if (window.console && window.console.warn) {\n        window.console.warn(message);\n    } else if (window.console && window.console.log) {\n        window.console.log(message);\n    }\n}\n\nfunction parseQuery() {\n    var queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n\n    var params = {};\n\n    if (queryString && queryString.indexOf('?') === 0) {\n        queryString = queryString.slice(1);\n    }\n\n    if (!queryString) {\n        return params;\n    }\n\n    if (queryString.indexOf('=') === -1) {\n        throw new Error('Can not parse query string params: ' + queryString);\n    }\n\n    for (var _iterator2 = queryString.split('&'), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n        } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n        }\n\n        var pair = _ref2;\n\n        pair = pair.split('=');\n\n        if (pair[0] && pair[1]) {\n            params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n    }\n\n    return params;\n}\n// CONCATENATED MODULE: ./src/loader/load.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\nvar integrationResponder = responder();\n\nfunction onLoadCheckoutIntegration(callback) {\n    return integrationResponder.listen(callback);\n}\n\nfunction getIntegrationURLs() {\n\n    return {\n        latest: isLatest(),\n        major: config.checkoutjs_url.replace('{version}', ''),\n        minor: config.checkoutjs_url.replace('{version}', '.' + getVersion())\n    };\n}\n\nfunction getIntegrationProps() {\n\n    var props = _extends({}, config.script_props);\n\n    var query = parseQuery();\n\n    if (query.env) {\n        props['data-env'] = query.env;\n    }\n\n    if (query.stage) {\n        props['data-stage'] = query.stage;\n    }\n\n    return props;\n}\n\nfunction loadCheckoutIntegration(callback) {\n\n    if (!isCheckoutXComponent()) {\n        return callback(null, null);\n    }\n\n    var urls = getIntegrationURLs();\n    var props = getIntegrationProps();\n\n    loadScript(urls.latest ? urls.major : urls.minor, config.xchild_global, props, function (err, result) {\n\n        if (err && !urls.latest) {\n            return loadScript(urls.major + '?t=' + Date.now(), config.xchild_global, props, callback);\n        }\n\n        return callback(err, result);\n    });\n}\n\nloadCheckoutIntegration(function (err, result) {\n\n    if (err) {\n        warn('Failed to load checkout.js', err.stack || err.toString());\n    }\n\n    if (err || result) {\n        return integrationResponder.respond(err, result);\n    }\n});\n// CONCATENATED MODULE: ./src/loader/interface.js\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"onLoadCheckoutIntegration\", function() { return onLoadCheckoutIntegration; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"isCheckoutXComponent\", function() { return isCheckoutXComponent; });\n\n\n\n/***/ }),\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"./node_modules/zalgo-promise/src/index.js\");\nmodule.exports = __webpack_require__(\"./src/loader/index.js\");\n\n\n/***/ })\n\n/******/ })));\n\n\n// WEBPACK FOOTER //\n// checkout.child.loader.min.js"," \tfunction getPromiseShim() {\n \t                            return __webpack_require__(\"./node_modules/zalgo-promise/src/index.js\")[\"ZalgoPromise\"];\n \t                        }\n\n \t                        function Promise(resolver) {\n \t                            return new (getPromiseShim())(resolver);\n \t                        }\n\n \t                        Promise.resolve = function(val)      { return getPromiseShim().resolve(val);  };\n \t                        Promise.reject  = function(err)      { return getPromiseShim().reject(err);   };\n \t                        Promise.all     = function(promises) { return getPromiseShim().all(promises); };\n\n \t                        \n \t                    \n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"https://www.paypalobjects.com/api/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2338747caf5320952c45","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\ntype ZalgoGlobalType = {\n    flushPromises : Array<ZalgoPromise<mixed>>,\n    activeCount : number,\n    possiblyUnhandledPromiseHandlers : Array<(mixed) => void>,\n    dispatchedErrors : Array<mixed>\n};\n\nexport function getGlobal() : ZalgoGlobalType {\n\n    let glob;\n\n    if (typeof window !== 'undefined') {\n        glob = window;\n    } else if (typeof global !== 'undefined') {\n        glob = global;\n    } else {\n        throw new Error(`Can not find global`);\n    }\n\n    if (!glob.__zalgopromise__) {\n        glob.__zalgopromise__ = {\n            flushPromises: [],\n            activeCount: 0,\n            possiblyUnhandledPromiseHandlers: [],\n            dispatchedErrors: []\n        };\n    }\n\n    return glob.__zalgopromise__;\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/global.js","\nexport function isPromise(item) {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        let toString = ({}).toString;\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/utils.js","\nimport { getGlobal } from './global';\n\nexport function dispatchPossiblyUnhandledError(err) {\n\n    if (getGlobal().dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    getGlobal().dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < getGlobal().possiblyUnhandledPromiseHandlers.length; j++) {\n        getGlobal().possiblyUnhandledPromiseHandlers[j](err);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler) {\n    getGlobal().possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            getGlobal().possiblyUnhandledPromiseHandlers.splice(getGlobal().possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/exceptions.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { getGlobal } from './global';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${err}`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) {\n        this.errorHandled = true;\n        this.reject(error);\n    }\n\n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        getGlobal().activeCount += 1;\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    result.then(res => { promise.resolve(res); },\n                                err => { promise.reject(err);  });\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        getGlobal().activeCount -= 1;\n\n        if (getGlobal().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    }\n\n    then<X : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | X), onError : void | (error : mixed) => (ZalgoPromise<X> | X)) : ZalgoPromise<X> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed>(onError : (error : mixed) => X | ZalgoPromise<X>) : ZalgoPromise<X> {\n        return this.then(undefined, onError);\n    }\n\n    finally(handler : () => mixed) : ZalgoPromise<R> {\n        return this.then((result) => {\n            return ZalgoPromise.try(handler)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(handler)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${time}ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new Error(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this);\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static all<X: Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> {\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            ZalgoPromise.resolve(prom).then(result => {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                promise.reject(err);\n            });\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<A, O : { [string] : (A | ZalgoPromise<A>) }>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> {\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => mixed) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | X), context : ?C, args : ?A) : ZalgoPromise<X> {\n\n        let result;\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        let promise = new ZalgoPromise();\n        getGlobal().flushPromises.push(promise);\n\n        if (getGlobal().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    }\n\n    static flushQueue() {\n        let promisesToFlush = getGlobal().flushPromises;\n        getGlobal().flushPromises = [];\n\n        for (let promise of promisesToFlush) {\n            promise.resolve();\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/promise.js","/* @flow */\n\nimport { extendNamespace } from '../lib/namespace';\n\nlet _interface = require('./interface'); // eslint-disable-line import/no-commonjs\n\nextendNamespace(_interface, [ 'paypal' ]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/index.js","/* @flow */\n\nexport function extendNamespace(xports : Object, namespaces : Array<string> = [], childnamespaces : Array<string> = []) : Object {\n\n    for (let name of namespaces) {\n        let namespace = window[name];\n\n        if (!namespace) {\n            continue;\n        }\n\n        for (let childname of childnamespaces) {\n            let childnamespace = xports[childname];\n\n            if (namespace[childname]) {\n                childnamespace = { ...namespace[childname], ...childnamespace };\n            }\n\n            xports = { ...namespace, ...xports, [ childname ]: childnamespace };\n        }\n    }\n\n    for (let name of namespaces) {\n        window[name] = xports;\n    }\n\n    return xports;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/namespace.js","/* @flow */\n\nimport { config } from './config';\n\nexport function isCheckoutXComponent() : boolean {\n    if (window.name) {\n        let seg = window.name.split(config.name_separator);\n\n        if (seg[0] === config.xcomponent && seg[1] === config.ppcheckout) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function getVersion() : string {\n\n    if (!isCheckoutXComponent()) {\n        throw new Error(`Can not get version for non-xcomponent`);\n    }\n\n    return window.name.split(config.name_separator)[2].replace(/_/g, '.');\n}\n\nexport function isLatest() : boolean {\n\n    if (!isCheckoutXComponent()) {\n        return false;\n    }\n\n    let version = getVersion();\n\n    return Boolean(version === config.major_version || version === config.latest_version);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/component.js","/* @flow */\n\nexport function loadScript(url : string, prop : string, attrs : Object, callback : (err : ?Error, res : ?mixed) => void) : void {\n\n    if (window[prop]) {\n        return callback(null, window[prop]);\n    }\n\n    let container = document.body || document.head;\n\n    if (!container) {\n        return callback(new Error(`Can not find container to insert script into`));\n    }\n\n    let script = document.createElement('script');\n\n    script.src = url;\n\n    script.onload = () => {\n        if (!window[prop]) {\n            return callback(new Error(`Expected ${ prop } to be present on window`));\n        }\n\n        return callback(null, window[prop]);\n    };\n\n    script.onerror = (err : Error) => {\n        return callback(err);\n    };\n\n    for (let attr of Object.keys(attrs)) {\n        script.setAttribute(attr, attrs[attr]);\n    }\n\n    container.appendChild(script);\n}\n\nexport function warn(...args : Array<string>) {\n    let message = args.join(' ');\n\n    if (window.console && window.console.warn) {\n        window.console.warn(message);\n    } else if (window.console && window.console.log) {\n        window.console.log(message);\n    }\n}\n\nexport function parseQuery(queryString : string = window.location.search) : Object {\n\n    let params = {};\n\n    if (queryString && queryString.indexOf('?') === 0) {\n        queryString = queryString.slice(1);\n    }\n\n    if (!queryString) {\n        return params;\n    }\n\n    if (queryString.indexOf('=') === -1) {\n        throw new Error(`Can not parse query string params: ${ queryString }`);\n    }\n\n    for (let pair of queryString.split('&')) {\n        pair = pair.split('=');\n\n        if (pair[0] && pair[1]) {\n            params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n    }\n\n    return params;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/util.js","/* @flow */\n\nimport { config } from './config';\nimport { responder } from './responder';\nimport { isLatest, getVersion, isCheckoutXComponent } from './component';\nimport { loadScript, warn, parseQuery } from './util';\n\nlet integrationResponder = responder();\n\nexport function onLoadCheckoutIntegration(callback : (err : ?Error, result : ?mixed) => void) : void {\n    return integrationResponder.listen(callback);\n}\n\nfunction getIntegrationURLs() : { latest : boolean, major : string, minor : string } {\n\n    return {\n        latest: isLatest(),\n        major:  config.checkoutjs_url.replace('{version}', ''),\n        minor:  config.checkoutjs_url.replace('{version}', `.${ getVersion() }`)\n    };\n}\n\nfunction getIntegrationProps() : Object {\n\n    let props = { ...config.script_props };\n\n    let query = parseQuery();\n\n    if (query.env) {\n        props['data-env'] = query.env;\n    }\n\n    if (query.stage) {\n        props['data-stage'] = query.stage;\n    }\n\n    return props;\n}\n\nfunction loadCheckoutIntegration(callback : (err : ?Error, result : ?mixed) => void) : void {\n\n    if (!isCheckoutXComponent()) {\n        return callback(null, null);\n    }\n\n    let urls = getIntegrationURLs();\n    let props = getIntegrationProps();\n\n    loadScript(urls.latest ? urls.major : urls.minor, config.xchild_global, props, (err, result) => {\n\n        if (err && !urls.latest) {\n            return loadScript(`${ urls.major }?t=${ Date.now() }`, config.xchild_global, props, callback);\n        }\n\n        return callback(err, result);\n    });\n}\n\nloadCheckoutIntegration((err : ?Error, result : ?mixed) : void => {\n\n    if (err) {\n        warn('Failed to load checkout.js', err.stack || err.toString());\n    }\n\n    if (err || result) {\n        return integrationResponder.respond(err, result);\n    }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/load.js","/* @flow */\n\nexport let config = {\n    checkoutjs_url: 'https://www.paypalobjects.com/api/checkout{version}.js',\n    major_version:  '4',\n    latest_version: 'latest',\n    xcomponent:     'xcomponent',\n    ppcheckout:     'ppcheckout',\n    xchild_global:  'xchild',\n    name_separator: '__',\n\n    script_props: {\n        'data-paypal-checkout': '',\n        'data-no-bridge':       '',\n        'data-state':           'ppxo_checkout'\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/config.js","/* @flow */\n\nexport function responder() : { respond : (error : ?Error, result : ?mixed) => void, listen : (callback : (error : ?Error, result : ?mixed) => void) => void } {\n\n    let callbacks = [];\n    let loaded = false;\n\n    let err;\n    let res;\n\n    function flush() {\n        if (loaded) {\n            while (callbacks.length) {\n                callbacks.shift()(err, res);\n            }\n        }\n    }\n\n    function respond(error : ?Error, result : ?mixed) {\n\n        loaded = true;\n        err    = error;\n        res    = result;\n\n        flush();\n    }\n\n    function listen(callback : (error : ?Error, result : ?mixed) => void) {\n        callbacks.push(callback);\n        flush();\n    }\n\n    return { respond, listen };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/responder.js"],"sourceRoot":""}